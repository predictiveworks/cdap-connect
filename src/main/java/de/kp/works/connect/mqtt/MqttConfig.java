package de.kp.works.connect.mqtt;
/*
 * Copyright (c) 2020 Dr. Krusche & Partner PartG. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 * 
 * @author Stefan Krusche, Dr. Krusche & Partner PartG
 * 
 */

import java.io.Serializable;
import java.util.stream.Stream;

import javax.annotation.Nullable;

import com.google.common.base.Strings;

import co.cask.cdap.api.annotation.Description;
import co.cask.cdap.api.annotation.Macro;
import de.kp.works.connect.BaseConfig;

public class MqttConfig extends BaseConfig implements Serializable {

	private static final long serialVersionUID = 1193310212809609121L;

	private static final String USER_DESC = "The MQTT user name or equivalent, such as the identifier "
			+ "of an application registered with an IoT cloud service.";
	
	private static final String PASSWORD_DESC = "The MQTT password or equivalent, such as the application "
			+ "key generated by an IoT cloud service.";
	
	private static final String CA_CERT_DESC = "The path to the file that contains the CA certificate.";
	
	private static final String CERT_DESC = "The path to the file that contains the client certificate.";
	
	private static final String PRIVATE_KEY_DESC = "The path to the file that contains the private key.";
	
	private static final String PRIVATE_KEY_PASSWORD_DESC = "The password to read the private key.";
	
	@Description("The address of the MQTT broker to connect to, including protocol and port.")
	@Macro
	public String mqttBroker;

	@Description("The comma-separated list of MQTT topics to listen to.")
	@Macro
	public String mqttTopics;

	/***** AUTHENTICATION *****/
	
	/*
	 * IMPORTANT: This approach is for testing;
	 * it is not recommended for producton
	 */
	
	@Description("The MQTT authentication method. Supported values are 'basic' and 'x509'. Default is 'basic'.")
	@Macro
	public String mqttAuth;
	
	@Description(USER_DESC)
	@Macro
	@Nullable
	public String mqttUser;

	@Description(PASSWORD_DESC)
	@Macro
	@Nullable
	public String mqttPassword;

	@Description(CA_CERT_DESC)
	@Macro
	@Nullable
	public String mqttCaCertFile;

	@Description(CERT_DESC)
	@Macro
	@Nullable
	public String mqttCertFile;

	@Description(PRIVATE_KEY_DESC)
	@Macro
	@Nullable
	public String mqttKeyFile;

	@Description(PRIVATE_KEY_PASSWORD_DESC)
	@Macro
	@Nullable
	public String mqttKeyPass;
	
	@Override
	public void validate() {
		super.validate();

		String className = this.getClass().getName();
		
		if (Strings.isNullOrEmpty(mqttBroker)) {
			throw new IllegalArgumentException(
					String.format("[%s] The MQTT broker address must not be empty.", className));
		}

		if (Strings.isNullOrEmpty(mqttTopics)) {
			throw new IllegalArgumentException(
					String.format("[%s] The MQTT topics must not be empty.", className));
		}
		
		/* Validate quthentication */
		
		MqttAuth auth = getAuth();
		switch (auth) {
		case BASIC: {
			
			if (Strings.isNullOrEmpty(mqttUser)) {
				throw new IllegalArgumentException(
						String.format("[%s] The MQTT user name must not be empty.", className));
			}
			
			if (Strings.isNullOrEmpty(mqttPassword)) {
				throw new IllegalArgumentException(
						String.format("[%s] The MQTT password must not be empty.", className));
			}
			
			break;
		}
		case X509: {
			
			if (Strings.isNullOrEmpty(mqttCaCertFile)) {
				throw new IllegalArgumentException(
						String.format("[%s] The path to the CA certificate file must not be empty.", className));
			}
			
			if (Strings.isNullOrEmpty(mqttCertFile)) {
				throw new IllegalArgumentException(
						String.format("[%s] The path to the client certificate file must not be empty.", className));
			}
			
			if (Strings.isNullOrEmpty(mqttKeyFile)) {
				throw new IllegalArgumentException(
						String.format("[%s] The path to the private key file must not be empty.", className));
			}
			
			if (Strings.isNullOrEmpty(mqttKeyPass)) {
				throw new IllegalArgumentException(
						String.format("[%s] The password for the private key must not be empty.", className));
			}
			
			break;
		}
		}
		

	}
	
	public MqttAuth getAuth() {
		
		Class<MqttAuth> enumClazz = MqttAuth.class;

		return Stream.of(enumClazz.getEnumConstants())
				.filter(keyType -> keyType.getValue().equalsIgnoreCase(mqttAuth)).findAny()
				.orElseThrow(() -> new IllegalArgumentException(
						String.format("Unsupported value for authentication method: '%s'", mqttAuth)));

	}
	
	public String[] getTopics() {
		
		String[] tokens = mqttTopics.split(",");
		String[]topics = new String[tokens.length];
		
		for (int i = 0; i < tokens.length; i++) {
			topics[i] = tokens[i].trim();
		}
		
		return topics;
		
	}
}
